api 데이터 불러오는 것 복습하기
MongoDB 데이터 구조화 규칙 블로그 읽어보기


// 자기계발 경쟁앱

- done -
- yet -

9/28

- done -
express 오류 검증 수강
캐스트는 무엇인가
CRUD 과정 이해하기
내장 오류 처리기 대신 커스텀 오류 처리기 이용
오류 코드 res.send() 대신 res.render()로 오류 페이지 만들기
오류 검증 코드 - 오류가 어느 출처에서 발생하는지에 따라 작동되는 코드가 다르다. Mongoose 측에서 발생하면 내가 쓴 코드는 작동을 건너뛰고 바로 오류 미들웨어로 넘어감

- yet -


9/29

- done -
OOP - 객체 지향 프로그래밍. 반복해서 사용할 수 있는 틀을 생성하고(프로토타입, 클래스) 해당 틀로부터 인스턴스를 생성하여 코드 작성의 중복을 줄이고 효율적으로 재사용하는 방법
this 개념 복습 - this가 참조하는 범위는 this가 작성된, 사용된 위치에 따라 다르다. 일반 함수, 전역 범위의 위치에서 사용하면 window 객체를 참조하고, 특정 객체 내에서 사용된 this는 해당 객체를 참조한다. 생성자 함수에서는 new를 통해 새로운 객체가 생성되기 때문에 해당 객체를 참조하고, 화살표 함수에서는 해당 this가 작성된 컨텍스트를 유지한다. this가 작성된 화살표 함수의 상위 스코프에 존재하는 객체를 참조한다.

스코프 개념 - 자바스크립트에서 변수, 함수, 객체에 접근할 수 있는 범위. 크게 전역 스코프와 지역 스코프가 존재한다.

클래스 복습 - 클래스는 생성자 함수의 불편함을 해소하기 위해 만들어진 방법이다. Class 키워드를 작성하고 대문자로 클래스를 시작한다. 해당 클래스는 중괄호를 열고 constructor를 먼저 작성한다. 이는 클래스로부터 새로운 인스턴스가 생성될 때마다 자동으로 실행되는 함수이며 주로 this 즉 new를 통해 생성될 객체 내의 변수를 정의하는 용도로 사용된다. Constructor 함수의 아래로는 prototype에 들어갈 메서드들을 정의할 수 있다. 함수 작성식으로 메서드를 작성하게 되면 프로토타입으로서 모든 인스턴스들이 공유할 수 있게 된다. 클래스는 extends, super를 통해 상속, 재사용이 가능하다.

- yet -



9/30 13:25~16:42

- done -
클라이언트 사이드에서 1차 방어, 서버 사이드에서 오류 처리 미들웨어를 통한 2차 방어
Yelp camp 오류 처리 연습
클라이언트 사이드, 서버 사이드 유효성 검사 차이가 뭔지?: 유효성 검사에 있어서 클라이언트 사이드의 경우는 사용자 경험을 중점으로 즉각적인 피드백을 제공하고 서버 사이드는 서버에 저장될 데이터의 보안과 안정성을 목적으로 실시한다. (Joi)
오류 처리 & mongo relationship 강의 수강

- yet -


10/1 10:07~11:42 / 13:43~16:25

- done -
Mongo relationship 연습 (one to many)
Express와 mongo 연결 파트 수강
Farm product 연결 연습하기 (farm 생성, product 연결되어 생성, 삭제 미들웨어)

비동기, Promise, 비동기 복습
- 콜백 함수는 어떠한 함수가 실행된 후에 동작하도록 설계된 함수이다. 보통 콜백 함수는 성공과 실패의 2가지 경우에 대한 함수를 생성하는데, 짧고 작은 기능의 함수에선 크게 문제가 되지 않지만 많은 중첩 관계 속에서 콜백 함수를 작성하게 되면 코드가 복잡해지고 가독성일 떨어져 유지 보수 및 개발 경험에 부정적인 영향을 준다. 이를 보완하기 위하여 Promise라는 개념이 등장했는데, Promise는 특정한 함수의 실행 결과를 담고 있는 객체로서, 성공(resolve)과 실패(reject)를 최종적으로 반환해준다. Promise와 함께 then, catch를 사용하면 보다 가독성이 올라간 코드를 작성할 수 있게 된다. 이를 더욱 보완한 것이 비동기 함수 async, await이다. Async는 함수를 비동기 함수로 만들고 반환 결과를 Promise가 되게 만들어준다. await는 함수가 Promise를 반환할 때까지 기다리게끔 만든다. 앞선 두 키워드를 통해 함수는 비동기의 Promise를 반환하는 함수가 되고 Promise를 반환할 때까지 다음 동작을 기다림으로써 콜백과 같은 기능을 수행하지만 가독성은 크게 향상된 코드를 작성할 수 있다. 콜백과 Promise의 경우 성공과 실패에 대한 함수(각각 성공 및 실패 함수, resolve & reject)가 존재하는데, async & await의 경우에는 try catch 구문을 사용함으로써 오류 상황을 처리할 수 있다.

콜백 함수는 다른 함수의 인자로 전달되어 실행 흐름이 끝난 후 호출되는 함수이다. 비동기 작업에서 성공/실패 시 처리 로직을 분리할 수 있지만, 콜백이 중첩되면 가독성이 떨어지고 유지보수가 어려워진다(콜백 헬).
이를 개선한 것이 Promise로, "아직 완료되지 않은 비동기 연산의 결과"를 나타내는 객체이다. Promise는 pending → fulfilled(성공) 또는 pending → rejected(실패) 상태를 갖고, then, catch 메서드로 성공/실패 처리 흐름을 명확하게 관리할 수 있다.
이를 더 간결하게 표현하기 위해 async/await 문법이 도입되었다. async 함수는 항상 Promise를 반환하며, 내부에서 await 키워드를 사용하면 Promise가 해결될 때까지 기다린 뒤 그 결과 값을 얻는다. 이 과정에서 에러 처리는 try/catch 구문으로 처리할 수 있어 가독성이 뛰어나고 동기식 코드처럼 작성할 수 있다.

일반 함수, 화살표 함수 차이
표현 형식의 차이, this 바인딩 차이(동적, 상위 스코프 고정), arguments 유무, return 방식, 호이스팅, 프로토타입 및 생성자 함수

Scope
변수가 유효한 범위, 변수에 접근할 수 있는 범위
전역 스코프 : 코드 전역에서 접근 가능
함수 스코프 : 함수 내에서만 접근 가능
블록 스코프 : 블록 내에서만 접근 가능

Express middleware mongoose middleware
Express middleware : 요청과 응답 사이에서 특정한 작업을 처리하는 함수. (Req, res, next)의 형태를 가지며 주로 라우트 핸들러가 실행되기 전에 필요한 작업을 실시한다.
mongoose middleware : DB에 데이터를 저장 및 처리하기 전 후로 특정한 작업을 처리하는 함수. Shcema.pre .post("action", fn) 형태로 작성하고 캐스캐이팅 삭제 같은 기능을 담당한다. DB에 저장된 다큐먼트나 이를 작동하는 쿼리에 사용된다.

Mongo, mongoose 코드 차이 복습하기
: Mongosh의 경우 REPL 환경에서 서버 측에서 직접 코드를 입력, db.collection.method()와 같은 형태로 코드 작성. mongoose는 node.js 환경에서 애플리케이션 용으로 작성하고 model.method() 와 같은 형태로 코드를 입력한다.

비동기 함수는 Promise를 반환한다.
: 비동기 함수란 지금 당장 결과값을 줄 수 없으니 나중에 값을 주겠다는 함수. 이는 JS가 싱글 스레드 방식으로 작동하기 때문에 비동기 함수 실행으로 프로그램이 멈춰선 안되기 때문. 결국 나중에 결과값을 받기 위한 목적으로 컨테이너인 Promise 객체가 존재하는 것. 콜백 비동기 함수의 경우엔 작업이 완료될 때까지 기다리고 작업이 완료된 후 결과를 콜백에 제공하기에 Promise가 없음.

콜백 함수와 Promise 객체의 차이는 콜백 함수의 경우 결과값이 특정 함수 내의 인자로 반환되기 때문에 결과적으로 복잡한 중첩 코드가 발생하여 가독성이 낮아짐
Promise의 경우 결과값을 객체로 제공하기 때문에 .then .catch 등을 사용하여 보다 가독성 좋은 코드를 작성할 수 있음.

비동기 함수는 즉시 값을 반환할 수 없으므로, 결과를 나중에 담아 전달할 컨테이너인 Promise 객체를 반환한다.
콜백 기반 비동기 함수는 작업 완료 시 지정한 콜백 함수로 결과를 전달하며, 중첩될 경우 코드 가독성이 떨어질 수 있다.
반면 Promise는 객체에 결과를 담아 반환하고, .then()과 .catch()로 순차적/에러 처리 로직을 명확하게 작성할 수 있어 유지보수성이 높아진다.

- yet -

10/1 19:45~20:25 / 20:28~21:10

- done -
Yelpcamp review 연결 강의 수강
모델 생성, UI


- yet - 


10/6 21:06~22:00 / 22:09~22:39

- done - 
Yelp camp review 연결 직접 해보기
삭제(리뷰만, 캠프까지 다), 유효성 검사(리뷰 검증): schema.deleteMany({_id: {$in: data.reviews}})
라우터, 쿠키 강의 수강: 쿠키는 브라우저에 작은 정보를 저장해놓은 곳 - cookie-parser
세션: 쿠키는 저장할 수 있는 크기 제한, 안정성 문제로 세션에 대량의 정보를 브라우저 상 DB에 저장하고 해당 정보에 대한 일부 정보(ID)를 쿠키로 클라이언트 측에 전송한 뒤 전송된 쿠키를 통해 다시 세션 DB에서 연관된 정보를 제공한다.
세션 강의 수강

- yet - 

10/7 

... ^^

10/8 16:22~18:10 19:40~20:40

- done - 
플래시 강의 수강
라우터, 세션, 쿠키 실제 연습
errorWrapper function: async는 Promise를 반환하기 때문에 결과적으로 .catch()를 작성하여 오류를 검증할 수 있음
Yelp 재구성, 세션, 쿠키, 플래시 강의
Yelp 재구성, 세션, 쿠키 실습


10/9 11:06~11:36 / 11:49~12:25 / 14:16 ~ 15:33 / 15:42~16:30 / 16:33~17:52

- done -
플래시 실전 연습
Crypt, hash 강의 수강: 
bcrypt 해싱을 할 때는 비밀번호 입력 시 솔트와 코스트를 인코딩 하고 재검증 시 인코딩된 솔트와 코스트를 사용자가 입력한 비밀번호 평문에 적용하여 해싱을 다시 수행함으로써 해싱된 비밀번호와의 일치 여부를 확인한다. 서로 다른 유저가 같은 비밀번호를 사용할 때에는 비밀번호를 해싱하는 것 만으로는 어떤 계정이 해당 유저의 것인지는 알 수 없고 이때 유저 네임이 있기 때문에 정확한 계정이 무엇인지를 확인할 수 있다. 특정 사용자에 의해 생성된 저장 해시를 사용하기 때문에 솔트가 다른 것은 문제가 되지 않는다. 같은 비밀번호에 대해서도 사용자가 다르기 때문에 구별되는 솔트를 가지게 되니까.

bcrypt는 비밀번호를 해시할 때 각 해시마다 무작위 salt를 생성하고 cost(라운드)와 함께 최종 해시 문자열에 인코딩해서 저장한다. 따라서 동일한 평문 비밀번호라도 매번 다른 해시 값이 생성된다. 인증 과정에서는 사용자가 입력한 아이디(또는 이메일)로 사용자 레코드를 조회한 뒤, 그 레코드에 저장된 해시에서 salt와 cost를 추출해 입력한 평문에 동일한 방식으로 해시를 재계산하고 두 해시를 비교하여 일치 여부를 판단한다. 즉, 서로 다른 사용자가 같은 평문 비밀번호를 사용하더라도 각 계정의 저장 해시가 다르기 때문에 비교 기준(해당 사용자 레코드의 저장 해시)을 통해 정확하게 인증할 수 있다.
단, 데이터베이스가 유출되면 공격자는 각 사용자 해시에 대해 후보 비밀번호들을 오프라인으로 대입해 확인할 수 있으므로(사용자별 해시에 대해 반복 검사), 이를 방지하려면 강력한 KDF(bcrypt/Argon2 등)와 적절한 cost 설정, 충분히 복잡한 비밀번호 정책 및 멀티팩터 인증을 함께 사용하는 것이 중요하다.

인증 강의, 실습

Yelp 인증 강의, 실습


10/10 10:25~12:16 (1:51) / 14:11~15:24 (1:13) / 15:34 ~ 16:50 (1:15) = 4h 19m

- done -

Yelp 권한 부여 강의, 실습

campground에 author 연결하기 d
show에 author 표시하기 d
Author 권한 부여하기 d
Author 확인하는 미들웨어 생성 d
review도 동일하게 d

Mongoose objectId 객체에는 equals라는 내장 메서드가 있고 이는 objectId의 일치여부를 확인한다.

권한 부여를 관리할 때는 클라이언트 측과 서버 측(라우트)를 모두 관리해야 한다.

Yelp 컨트롤러 및 별점 강의, 실습 starability

이미지 업로드 강의

Library install(multer, cloudinary, muster-storage-cloudinary)
multer 등록, 이미지 upload경로로 받아오기



10/11 9:25~10:17 (0:52)/ 14:05~14:52 (0:47) / 15:00~16:25 (1:25) / 16:37~17:49 (1:12) = 4h:16m


Model campground image 변경함. 관련 코드들 오류 뜰 수 있음

cloudinary에서 데이터가 지워져도 특정 url로 사진을 확인할 수 있는 이유는 CDN 캐시가 남아 있기 때문에 일정 기간동안 해당 주소로 접근할 수는 있다. 하지만 주소에 transform api를 적용할 때에는 이미 해당하는 주소는 유효하지 않기 때문에 api가 적용되지 않는다.


이미지 업로드 실습(multer 이후로)


10/12 13:24~14:38 (1:14) / 14:42~16:05 (1:23) / 16:08~16:54 (0:46) /


- done -
Mapbox 구현 (libarary 사용 연습)



10/15 12:20~13:46(1:26) / 13:52~15:21 (1:29) / 18:56~20:25 (1:29) = 4h:34m

- done -
styling
보안
Mongo Atlas
사용자 정의 팝업 띄우기(virtual 사용), 앱 스타일링
Git 강의, 실습

- yet -



Axios, 인증, 오류 처리 복습
Passport 복습
미들웨어 복습

배포, GitHub 강의
Git, GitHub 실습



###### yelpcamp를 러닝 스팟 공유하는 앱으로 변경???!!?!?!!? #####

###### yelpcamp를 공유 데이터를 찾아서 실제 대한민국 캠핑장 앱으로 업데이트???!!?!?!!? #####
ㄴ 데이터 있음 xml 파일이라 변환 필요


10/17 14:22~



******직접 파일 만들어서 작성해보기******






(귀찮아도 일단 뚜들겨봐라....)